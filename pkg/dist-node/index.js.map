{"version":3,"file":"index.js","sources":["../dist-src/index.js"],"sourcesContent":["import _retry from 'async-retry';\nimport R from 'ramda';\nconst {\n  anyPass,\n  both,\n  complement,\n  compose,\n  constructN,\n  curry,\n  is,\n  ifElse,\n  invoker,\n  map,\n  propEq,\n  when,\n  type\n} = R;\n\nconst raise = err => {\n  throw err;\n};\n\nconst instanceOf = propEq('name');\n\nconst wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nconst until = timestampMs => timestampMs - Date.now();\n\nconst typeEq = curry((string, thing) => type(thing) === string);\nconst isDeltaSeconds = compose(both(typeEq('Number'), complement(Number.isNaN)), parseInt);\nconst getHeader = curry((header, response) => response.headers.get(header));\nconst getRateLimitReset = getHeader('RateLimit-Reset');\n\nclass RetryableError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'RetryableError';\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RetryableError);\n    }\n  }\n\n}\n\nconst knownErrors = ['RetryableError', 'FetchError', 'AbortError'];\nconst isRetryableError = both(is(Error), anyPass(map(instanceOf, knownErrors)));\nconst isRetryableStatus = anyPass([status => status >= 500 && status < 600, status => status === 429]);\n\nconst forceRetry = () => raise(new RetryableError('Retrying...'));\n/**\n * Retries up to `max` attempts only if `fetcher`:\n * - returns a `Response` with `status` 429 or 500â€“599\n * - throws a `FetchError` or `AbortError`\n * If retries exceed `max`, then the response is passed along,\n * whether an error or a response with a bad status.\n * Use retry behavior before handling bad statuses.\n * @async\n * @param {number} max\n * @param {() => Promise<Response>} fetcher\n * @returns {Promise<Response>}\n * @example\n * const fetchUserById = (id) => fetch(`/users/${id}`);\n * const safeFetchUserById = retry(3, () => fetchUserById(1));\n */\n\n\nconst retry = curry((max, fetcher) => _retry(async (bail, tries) => {\n  const canRetry = tries < max + 1;\n  return fetcher().then(async res => {\n    const resetHeader = getRateLimitReset(res);\n\n    if (resetHeader && res.status === 429) {\n      isDeltaSeconds(resetHeader) ? await compose(wait, sec => sec * 1000, parseInt)(resetHeader) : await compose(wait, until, invoker(0, 'getTime'), constructN(1, Date))(resetHeader);\n    }\n\n    return res;\n  }).then(when(res => isRetryableStatus(res.status) && canRetry, forceRetry)).catch(ifElse(isRetryableError, raise, bail));\n}, {\n  retries: max,\n  minTimeout: 10,\n  factor: 5\n}));\nexport default retry;"],"names":["anyPass","both","complement","compose","constructN","curry","is","ifElse","invoker","map","propEq","when","type","R","raise","err","instanceOf","wait","ms","Promise","resolve","setTimeout","until","timestampMs","Date","now","typeEq","string","thing","isDeltaSeconds","Number","isNaN","parseInt","getHeader","header","response","headers","get","getRateLimitReset","RetryableError","Error","constructor","message","name","captureStackTrace","knownErrors","isRetryableError","isRetryableStatus","status","forceRetry","retry","max","fetcher","_retry","bail","tries","canRetry","then","res","resetHeader","sec","catch","retries","minTimeout","factor"],"mappings":"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"}